# mongoDB(지마켓 기술 블로그)

## NoSQL의 등장 배경

- 인터넷 서비스가 점점 많은 곳에 보급되고 데이터를 전송하는 device의 수가 증가하면서, 기존의 RDB로는 취급하기 어려운 방대한 양의 비정형 데이터들을 적재하고 처리하기 위해 새로운 데이터 저장소가 필요해졌다.

### RDB의 한계

1. 비정형 데이터를 처리하기 어렵다
2. 확장성이 떨어진다
3. 상대적으로 속도가 느리다

- 데이터 포맷은 신경 쓰지 않고 넣을 수 있으면서, 서버 용량이 넘칠 것 같으면 쉽게 새로운 서버를 옆에 붙여서 확장할 수 있고, 엄청난 빈도로 읽기/쓰기 연산을 해도 성능에 큰 문제가 없는 것이 바로 MongoDB다.
- 분당 수만 건씩 쌓이는 사용자 로그를 RDB로 실시간으로 처리할 수 없기 때문에 MongoDB에 실시간으로 적재하고, 차후에 Batch process를  통해 정형화하여 하둡에 올려 관리하는 것이 합리적이다.

## MongoDB 스키마 설계를 위한 고려사항

RDB에서 스키마 설계는 엔티티를 정의하고 정규화를 통해 중복을 없애는 정형화된 프로세스를 따릅니다. 이에 비해 MongoDB는 application 관점에서 수행되는 쿼리의 성능을 고려하여 유연한 설계를 필요로 합니다.

### 설계 할 때 고려 사항

### Access Pattern

- Application이 어떤 쿼리들을 수행하는가?
- 어떤 쿼리를 가장 빈번하게 수행하는가?
- Application은 주로 DB에서 데이터를 읽는가? 아니면 쓰는가?

위의 질문들을 통해서 컬렉션을 정의합니다.

- 함께 조회되는 경우가 빈번한 데이터들은 같은 컬렉션에 담아서 쿼리 횟수를 줄일 수 있습니다.
- 주로 읽기만 하는 데이터와 자주 업데이터 되는 데이터는 별개의 컬렉션에 담습니다.

### Relation

Access Pattern을 분석해 컬렉션들이 정의되면 다음은 컬렉션 간의 관계를 파악합니다.

예를 들어 Product와 Category라는 두 컬렉션이 DB에 존재한다고 가정합니다. RDB에서는 Product 테이블에 category_id라는 컬럼을 두어 Category 테이블과 조인하여 카테고리 정보를 가져오도록 설계할 수 있습니다.

MongoDB에서는 컬렉션 간에 reference할 지, embed할 지를 결정해야 합니다. 여기서 reference란 컬렉션 간 참조할 수 있도록 id를 저장하는 것이고, embed는 관계된 document 전체를 저장하는 방식입니다.

![img](https://blog.kakaocdn.net/dn/enUXJE/btrHtw5f63Y/Thuz2PLS0c9QAiMFJn41mk/img.png)

​																									           reference 방식

​		<img src="https://blog.kakaocdn.net/dn/cM3Ej7/btrHsEbsPG1/6Bo2OdkXKl5Zz4JAP6JA4K/img.png" alt="img" style="zoom:40%;" />

​										   embed 방식



두 방식을 선택하는 기준은 **application의 성격**입니다. 

예를 들어, **상품 페이지에 카테고리 정보가 함께 보인다면** 두 정보는 대부분 함께 조회된다고 봐야 합니다. 따라서 쿼리 한번에 모두 가져올 수 있도록 **embed 방식**을 선택하는 것이 바람직합니다. 반면에 카테고리 정보가 끊임없이 변경되는 상황이라면 embed 방식의 경우, 해당 카테고리의 모든 상품 document를 찾아서 일일이 embed된 정보를 수정해야 합니다. 반면에 reference 방식의 경우 별도로 관리되는 카테고리 컬렉션에서 하나의 document만 찾아서 수정하면 됩니다. **잦은 수정이 예상되는 경우에는 reference 방식**이 더 바람직합니다.

Reference는 데이터를 정규화하고, embed는 데이터를 비정규화합니다. RDM과 다르게 MongoDB는 적절한 수준의 비정규화가 필요한 경우가 많습니다. 일반적으로 reference는 쓰기를 빠르게 하고, embed는 읽기를 빠르게 합니다.

분당 수천~수만 번 access되는 웹페이지에서 이용되는 정보라면 긍한 하나의 document에 모아두는 것이 필요하겠지만, 이런 설계에 정답은 없습니다.

### Cardinality

- One-to-One, One-to-Many, Many-to-Many가 존재합니다.

단순히 many에서 끝나는 게 아니라 how many가지 고려하는 것도 필요합니다.

책 한권이 갖는 태그는 기껏해야 10개 미만이지만, 태그 하나에 포함되는 도서는 수백~수천권이 될 것입니다. 즉 책과 태그는 Many-to-Few 관계라고 할 수 있습니다. 

일반적으로 적은 many는 embed, 많은 many는 개별 컬렉션을 두어 reference 하는 것이 바람직합니다.

### Embed vs Reference

| Embed 권장                         | Reference 권장                       |
| ---------------------------------- | ------------------------------------ |
| 변경이 거의 없는 정적인 데이터     | 변경이 잦은 데이터                   |
| 함께 조회되는 경우가 빈번한 데이터 | 조회되는 경우가 많지 않은 데이터     |
| 빠른 읽기가 필요한 경우            | 빠른 쓰기가 필요한 경우              |
| 결과적인 일관성이 허용될 때        | 즉각적으로 일관성이 충족되어야 할 때 |

