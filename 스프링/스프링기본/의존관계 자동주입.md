# 다양한 의존관계 주입 방법

- 생성자 주입
  - 생성자 호출 시점에 딱 1번만 호출되는 것이 보장된다.
  - 불변, 필수 의존 관계에 사용
- setter 주입
  - 선택, 변경 가능성이 있는 의존 관계에 사용
- 필드 주입
  - 필드에 바로 주입하는 방법
  - 코드가 간결하지만 외부에서 변경이 불가능해서 테스트가 힘들다
  - DI 프레임워크가 없으면 아무것도 할 수 없다.
  - 사용하지 말자 (테스트 코드에서만 사용)
- 일반 메서드 주입
  - 한번에 여러 필드를 주입 받을 수 있다.



**옵션 처리**

주입할 스프링 빈이 없어도 동작해야 할 때가 있다.

- @Autowired(required=false) : 자동 주입 대상이 없으면 수정자 메서드가 호출되지 않음.
- @Nullable : 자동 주입 대상이 없으면 null이 입력된다.
- Optional<> : 자동 주입 대상이 없으면 Optional.empty가 입력된다.



 ➨ 생성자 주입을 선택해라!

**불변**

- 대부분 의존관계 주입은 애플리케이션 종료시점까지 의존관계를 변경할 일이 없다.
- setter 주입의 경우는 누군가 실수로 변경할 수도 있다.
- 생성자 주입은 객체를 생성할 때 1번만 호출되기 때문에 불변하게 설계가 가능하다.

**누락**

- setter 주입으로 코드를 짤 경우 테스트를 할 때 의존관계 주입이 없어도 실행은 되지만 NPE가 발생한다.
- 하지만 생성자 주입은 컴파일에서 오류를 잡아주기 때문에 더 효율적이다.
- 생성자 주입만 final 키워드를 사용할 수 있다.



# 동일한 타입의 스프링 빈이 2개 이상 조회된 경우

![image](https://user-images.githubusercontent.com/40904001/191476799-648042dc-44ce-4899-8f76-04ee6313ffbd.png)

![image](https://user-images.githubusercontent.com/40904001/191476878-06402c8b-dd80-4c73-9aed-95e788bd1771.png)

DiscountPolicy 타입을 조회하게 되면 스프링 빈에 RateDiscountPolicy와 FixDiscountPolicy가 조회되기 때문에 오류가 발생한다.

## 해결 방법

1. **@Autowired 필드 명**

![image](https://user-images.githubusercontent.com/40904001/191476384-d880773d-393c-4040-a355-e4abf567faa3.png)

- 필드명을 빈 이름으로 변경해주게 되면 해당 필드 명과 먼저 타입 매칭을 시도한다.

2. **@Qualifier**

![image](https://user-images.githubusercontent.com/40904001/191477914-a1336e96-0eb0-4b1e-baf3-f3af2a067f26.png)

![image](https://user-images.githubusercontent.com/40904001/191477972-3086ae1f-144c-49dc-86f1-87174d6635cf.png)

![image](https://user-images.githubusercontent.com/40904001/191478110-9eabe3cf-c87e-475a-9c16-c07b67bd18ab.png)

- 빈을 등록할 때 @Qualifier를 붙이고 이름을 정의한다.
- 의존 주입을 할 때 @Qualifier를 붙이고 등록한 이름을 적어준다.
- 존재하지 않는 이름을 적어주면 NoSuchBeanDefinitionException 예외가 발생한다.



3. **@Primary**

![image](https://user-images.githubusercontent.com/40904001/191478658-86d587e6-897a-4c63-9e56-0791ac2a2a4c.png)

- @Autowired를 할 때 여러 개의 빈이 매칭되면 @Primary를 가진 스프링 빈이 우선권을 가진다.

- 위의 경우는 rateDiscountPolicy가 우선권을 가진 경우다.



  ➨ **@Qualifier가 @Primary보다 우선순위가 높다**



#### 애노테이션 직접 만들기

- @Qualifier("mainDiscountPolicy") 이렇게 문자를 적으면 컴파일시 타입 체크가 안된다.

- 이 때 애노테이션을 직접 만들면 문제를 해결할 수 있다.

  ![image](https://user-images.githubusercontent.com/40904001/191481216-bbef743e-3bfb-4a59-8b74-05e68b361290.png)

- 해당 애노테이션을 필요한 곳에 넣어주면 똑같은 기능을 수행하고, 오타가 나게 되면 컴파일에서 오류를 잡아준다.

  ![image](https://user-images.githubusercontent.com/40904001/191481456-d12e7115-72c0-4612-9af0-c77cd0db096f.png)







## 꿀팁

- 메인 데이터베이스의 커넥션을 획득하는 스프링 빈은 **@Primary** 를 적용해서 조회하는 곳에서 @Qualifier 지정 없이 편리하게 조회한다.

- 서브 데이터베이스 커넥션 빈을 획득할 때는 **@Qualifier** 를 지정해서 명시적으로 획득 하는 방식으로 사용하면 코드를 깔끔하게 유지할 수 있다

  

## 수동 빈 등록은 언제 사용하면 좋을까?

**애플리케이션은 크게 업무 로직과 기술 지원 로직으로 나눌 수 있다.**

- 업무 로직의 경우 숫자도 많고, 한번 개발해야 하면 컨트롤러, 서비스, 리포지토리 처럼 어느 정도 유사한 패턴이 있다. 이런 경우에는 자동 등록을 사용하는 것이 좋다.

   ➨ 문제가 발생하더라고 어떤 곳에서 발생했는 지 파악하기 쉽다.

- 기술 지원 로직은 업무 로직에 비해 그 수가 매우 적고, 보통 애플리케이션 전반에 영향을 미친다. 그리고 기술 지원 로직은 문제가 발생했을 때 어디서 발생했는 지 파악하기 어려운 경우가 많다

   ➨ 이 때 수동 빈 등록을 사용해서 명확하게 드러내는 것이 좋다.



**비즈니스 로직 중에서 다형성을 적극 활용할 때**

의존관계 자동 주입으로 Map에 주입을 받는 상황에서 어떤 빈들이 주입될 지, 각 빈들의 이름이 뭔지 코드만 보고 쉽게 파악할 수 없다. 

- 수동으로 등록한다.

- 자동 등록으로 하면 특정 패키지에 같이 묶어 두는 게 좋다.



**정리**

- 편리한 자동 기능을 기본으로 사용
- 직접 등록하는 기술 지원 객체는 수동 등록
- 다형성을 적극 활용하는 비즈니스 로직은 수동을 고민해보자
