# 빈 스코프

- 싱글톤
- 프로토타입
- 웹 관련 스코프
  - request
  - session
  - application



**컴포넌트 스캔 자동 등록**

![image](https://user-images.githubusercontent.com/40904001/191663426-50134bad-f4c8-4995-b4af-49d4885e47d4.png)

**수동 등록**

![image](https://user-images.githubusercontent.com/40904001/191663587-f773cd69-1bc7-4787-aa7f-9adf7b9c8869.png)



## 프로토타입 스코프

- 싱글톤과 달리 프로토타입 스코프를 스프링 컨테이너에 조회하면 항상 새로운 인스턴스를 생성해서 반환한다.

  ![image](https://user-images.githubusercontent.com/40904001/191663862-bc7ccfd8-4b89-442b-b50e-63a8c370c972.png)

- 프로토타입 스코프의 빈을 스프링 컨테이너에 요청

- 스프링 컨테이너는 이 시점에 빈을 생성하고, 필요한 의존관계를 주입한다.

  ![image](https://user-images.githubusercontent.com/40904001/191664057-5d943006-d877-43b8-a873-7600eff4e5da.png)

- 생성한 프로토타입 빈을 클라이언트에 반환

- 이후 스프링 컨테이너에 같은 요청이 오면 새로운 빈을 생성해서 반환한다.

​	 ➨  **핵심은 스프링 컨테이너는 프로토타입 빈을 생성, 의존관계 주입, 초기화까지만 처리한다는 것**

- 그렇기 때문에 @PreDestroy 같은 종료 메서드도 호출되지 않는다.



## 싱글톤 스코프

![image](https://user-images.githubusercontent.com/40904001/191664525-d260d8b7-16d5-439f-929f-c48698a0c157.png)

- 싱글톤 스코프 빈을 스프링 컨테이너에 요청
- 스프링 컨테이너는 본인이 관리하는 스프링 빈을 반환
- 이후 같은 요청이 와도 같은 객체 인스턴스의 스프링 빈을 반환



## 프로토타입 스코프와 싱글톤 스코프

- 싱글톤 빈은 스프링 컨테이너 생성 시점에 초기화 메서드가 실행되지만, 프로토타입 스코프 빈은 스프링 컨테이너에서 빈을 조회할 때 생성되고, 초기화 메서드도 실행된다.
- 싱글톤 빈은 스프링 컨테이너가 종료될 때까지 스프링 컨테이너에서 관리되기 때문에 종료 메서드가 실행되지만, 프로토타입 빈은 스프링 컨테이너가 초기화까지만 관리하기 때문에 스프링 컨테이너가 종료되도 종료 메서드가 실행되지 않는다.



## 프로토타입 스코프 - 싱글톤 빈과 함께 사용시 문제점

**싱글톤에서 프로토타입 빈 사용**

![image](https://user-images.githubusercontent.com/40904001/191665339-1c00b3a5-1fb3-4c8f-81ab-176863af793d.png)

- clientBean은 싱글톤이므로, 스프링 컨테이너 생성 시점에 함께 생성되고, 의존관계 주입도 발생한다.
- clientBean은 의존관계 자동 주입을 사용한다. 주입 시점에 스프링 컨테이너에 프로토타입 빈을 요청한다.
- 스프링 컨테이너는 프로토타입 빈을 생성해서 clientBean에 반환한다.
- clientBean은 내부 필드에 프로토타입 빈을 갖게 된다.

![image](https://user-images.githubusercontent.com/40904001/191665736-a7b9230a-e997-44c0-8d16-fa3c481a9c2c.png)

- 클라이언트 A가 clientBean을 요청해서 받는다. 싱글톤이기 때문에 항상 같은 clientBean을 받게 된다.

- 클라이언트 A가 clientBean.logic()을 호출한다.

- clientBean은 prototypeBean의 addCount()를 호출해서 count를 증가시킨다. (0 ➝ 1)

  ![image](https://user-images.githubusercontent.com/40904001/191666096-ff29372a-f4d8-4e60-9612-e0a77d095039.png)

- 클라이언트 B도 클라이언트 A와 동일하게 요청을 받고, logic()을 호출하여 count를 증가시킨다.
- 이 때, clientBean의 내부에 있는 프로토타입 빈은 과거에 주입이 끝난 빈이다. 주입 시점에 스프링 컨테이너에 요청을 할 때 새로 생성되는 것이지, 사용할 때마다 새로 생성되는 것이 아니다.
- 그렇기 때문에 count가 1 ➝ 2가 된다.



## 프로토타입 스코프 - 싱글톤 빈과 함께 사용시 Provider로 해결

- 지정한 빈을 컨테이너에서 대신 찾아주는 DL(Dependency Lookup) 서비스를 제공하는 것이 ObjectProvider

  ![image](https://user-images.githubusercontent.com/40904001/191701505-49a215a1-0e77-40b4-920f-74d177ede57b.png)

- prototypeBeanProvider.getObject()를 호출하면서 스프링 컨테이너를 통해 해당 빈을 찾아서 반환해준다.



### JSR-330 Provider

- javax.inject.Provider라는 자바 표준을 사용하는 방법

  ![image](https://user-images.githubusercontent.com/40904001/191701868-dc81af4f-58e6-4304-9d69-f0b13ef0df06.png)

- 위의 ObjectProvider.getObject()와 기능이 동일하다.
- 자바 표준이기 때문에 스프링에 의존적이지 않다.
- 별도의 라이브러리가 필요하다.



## 실무에서 뭘 쓰는게 더 좋을까?

- ObjectProvider는 DL을 위한 편의 기능을 제공해주고 스프링 외에 별도의 의존관계 추가가 필요가 없기 때문에 편리하다.
- 만약 코드를 스프링이 아닌 다른 컨테이너에서도 사용할 수 있으려면 JSR-330 Provider를 사용해야 한다.



## 웹 스코프 - request 스코프

- HTTP 요청당 빈이 생성되고 요청이 끝나는 시점에 소멸된다.
- HttpServletRequest를 통해서 요청 URL을 받는다.
- 서비스 계층은 웹 기술에 종속되지 않고, 가급적 순수하게 유지하는 것이 좋다.

**[실행 결과]**

![image](https://user-images.githubusercontent.com/40904001/191717951-52f4c075-71c2-47aa-8c15-c8e992f9807a.png)



**오류가 발생하는 이유**

![image](https://user-images.githubusercontent.com/40904001/191718529-9e2c0a96-b3e7-41f9-896e-332826cbd3ab.png)

![image](https://user-images.githubusercontent.com/40904001/191718623-93b4d1b3-891d-4187-b303-97c15a742c38.png)

스프링 애플리케이션이 실행되는 시점에 빈에 등록된 myLogger는 의존 주입을 받게 된다. 그런데 request 스코프 빈은 HTTP 요청이 올 때 생성되기 때문에 request가 존재하지 않게 된다. 그래서 오류가 터지게 되는 것이다.



## 해결 방법

- ObjectProvider

  ![image](https://user-images.githubusercontent.com/40904001/191719718-0369763b-5b52-494c-817f-4518bad3a682.png)

  ![image](https://user-images.githubusercontent.com/40904001/191719832-1d4e0b37-2c0d-4461-92a7-571c77bcadd9.png)

- @Scope에 있는 proxyMode

  - 적용 대상이 클래스면 TARGET_CLASS
  - 적용 대상이 인터페이스면 INTERFACES

  해당 방법의 경우 Provider를 사용하기 전 코드와 완전히 동일하지만 정상적으로 동작한다.

  ### 웹 스코프와 프록시 동작 원리

  - 이전에 @Configuration에서처럼 CGLIB라는 라이브러리로 MyLogger를 상속 받은 가짜 프록시 객체를 만들어서 스프링 빈에 등록하게 된다.

    ![image](https://user-images.githubusercontent.com/40904001/191720315-40a4379c-367c-45fe-b073-a0edb1b32fcd.png)
    
  - **가짜 프록시 객체는 요청이 오면 그 때 내부에서 진짜 빈을 요청한다.**
  
  - 가짜 프록시 객체는 실제 request 스코프와 관계가 없고, 단순히 위임 로직만 있고, 싱글톤처럼 동작한다.

### 특징 정리

- 프록시 객체 덕분에 클라이언트는 싱글통 빈을 사용하듯 편리하게 request 스코프를 사용할 수 있다.
- 결국 핵심은 진짜 객체 조회를 꼭 필요한 시점까지 지연처리 한다는 점이다.ㄴ



