# 사용자 정의 리포지토리 구현

- 스프링 데이터 JPA가 제공하는 인터페이스가 너무 많기 때문에 전부 직접 구현하기 힘들다.
- 이 때 인터페이스의 메서드를 직접 구현하고 싶다면?
  - JPA 직접 사용
  - 스프링 JDBC Template 사용
  - MyBatis 사용
  - 데이터베이스 커넥션 직접 사용
  - Querydsl 사용

- 사용자 정의 구현 클래스
  - 규칙 : 리포지토리 인터페이스 이름 + Impl (최근에는 사용자정의 인터페이스 이름 + Impl 방식도 지원 )
  - 스프링 데이터 JPA가 인식해서 스프링 빈으로 등록한다.

- 실무에서 주로 QueryDSL이나 SpringJdbcTemplate을 함께 사용할 때 사용자 정의 리포지토리 기능을 사용한다.



# Auditing

엔티티를 생성, 변경할 때 변경한 사람과 시간을 추적하고 싶을 때?

- 등록일
- 수정일
- 등록자
- 수정자

## 순수 JPA 사용

@PrePersist : 저장하기 전에 동작하는 함수에 지정

@PreUpdate : 수정하기 전에 동작하는 함수에 지정

@PostPersist : 저장한 후에 동작하는 함수에 지정

@PotsUpdate : 수정하고 나서 동작하는 함수에 지정



## 스프링 데이터 JPA 사용

- @EnableJpaAuditing을 스프링 부트 설정 클래스에 적용해야 한다.

![image](https://user-images.githubusercontent.com/40904001/190884944-24462a09-78d2-4152-969c-da45c2bf2aad.png)

- @CreatedDate
- @LastModifiedDate
- @CreatedBy
- @LastModifiedBy

![image](https://user-images.githubusercontent.com/40904001/190884973-7fb53e93-409b-4a91-825a-f260236c208b.png)

- 등록자, 수정자의 경우는 AuditorAware 스프링 빈을 등록해줘야 한다.

  ![image](https://user-images.githubusercontent.com/40904001/190885002-e8896e25-17f3-4126-8885-6f7eed70fba6.png)



## 실무 꿀팁

실무에서는 등록자, 수정자는 없을 수도 있기 때문에 Base타입을 분리해서 원하는 타입을 선택해서 상속하게 해준다.





# Web 확장

## 1. 페이징과 정렬

![image](https://user-images.githubusercontent.com/40904001/190885449-54ab2f8a-01fc-4ef0-b016-42bdeb58e48f.png)

- 파라미터로 Pageable을 받을 수 있다.
- 실제로는 org.springframework.data.domain.PageRequest 객체 생성

**요청 파라미터**

- page: 현재 페이지, 0부터 시작
- size: 한 페이지에 노출할 데이터 건수(기본값 = 20)
- sort: 정렬 조건을 정의한다. (예: (ASC|DESC), 기본값 = ASC)

**사용자 지정으로 페이징, 정렬하는 방법**

1. application.yml (global)

   ![image](https://user-images.githubusercontent.com/40904001/190885541-337e7858-12b6-43a4-87c6-9cda4cc90078.png)

2. @PageableDefault(value, size, page, sort)

   ![image](https://user-images.githubusercontent.com/40904001/190885763-0b40fd26-6b99-423c-a75e-c67cc52997a9.png)

   엔티티를 반환하는 것보다 DTO로 변환하여 반환하는 것이 더 좋다.

