# 영속성 관리

## 영속성 컨텍스트

- JPA를 이해하는 데 가장 중요한 용어
- 엔티티를 영구 저장하는 환경이라는 뜻
- EntityManager.persist(entity);
- 영속성 컨텍스트는 논리적인 개념

## 엔티티의 생명주기

- 비영속 (new/transient)

  영속성 컨텍스트와 전혀 관계가 없는 새로운 상태

- 영속 (managed)

  영속성 컨텍스트가 관리되는 상태

- 준영속 (detached)

  영속성 컨텏트에 저장되었다가 분리된 상태

- 삭제 (removed)

  삭제된 상태

### 1. 비영속

![image](https://user-images.githubusercontent.com/40904001/191946011-6469b5b2-fca0-457c-bafb-69fee35b1733.png)

```java
//객체를 생성하기만 한 상태
Member member = new Member();
member.setId("member1");
member.setUsername("회원1");
```

### 2. 영속

![image](https://user-images.githubusercontent.com/40904001/191946044-5c5a6f89-b778-445d-81b1-445a254ed5b9.png)

```java
Member member = new Member();
member.setId("member1");
member.setUsername(“회원1”);

EntityManager em = emf.createEntityManager();
em.getTransaction().begin();

// 객체를 저장한 상태(영속)
em.persist(member);
```



### 3. 준영속, 삭제

```java
// 회원 엔티티를 영솏 컨텍스트에서 분리, 준영속 상태
em.detach(member);

//객체를 삭제한 상태
em.remove(member);
```



## 영속성 컨텍스트의 이점

- 1차 캐시

```java
Member member = new Member();
member.setId("member1");
member.setUsername("회원1");
//1차 캐시에 저장됨
em.persist(member);
//DB보다 먼저 1차 캐시에서 조회한다.
Member findMember = em.find(Member.class, "member1");
```

![image](https://user-images.githubusercontent.com/40904001/191946072-e4b42bdc-f3ab-4a50-b296-9486b9cd7394.png))

```java
Member findMember2 = em.find(Member.class, "member2");
```

![image](https://user-images.githubusercontent.com/40904001/191946098-8bf0f249-1d57-46d7-b086-15af994d628d.png)

1차 캐시에서 우선 조회하고 없으면 db에서 조회 후 1차 캐시에 저장합니다.

- 동일성 보장

  ```java
  Member a = em.find(Member.class, "member1");
  Member b = em.find(Member.class, "member1");
  System.out.println(a == b); //동일성 비교 true
  ```

  

- 트랜잭션을 지원하는 쓰기 지연

  ```java
  EntityManager em = emf.createEntityManager();
  EntityTransaction tx = em.getTransaction();
  //엔티티 매니저는 데이터 변경시 트랜잭션을 시작해야 한다.
  tx.begin();
  
  em.persist(member1);
  em.persist(member2);
  
  // 커밋하는 순간 데이터베이스에 insert 쿼리를 보낸다.
  tx.commit();
  ```

  ​                                                                                                     **em.persist()**

  ![image](https://user-images.githubusercontent.com/40904001/191946140-2644317e-034f-417b-872b-e17d0ea79871.png)

  - em.persist()로 엔티티를 저장하게 되면 1차캐시에 저장됨과 동시에 쓰기 지연 SQL 저장소에 쿼리문이 저장된다.

  ​                                                                                    **transaction.commit()**

  ![image](https://user-images.githubusercontent.com/40904001/191946169-45e8f129-d533-4b99-8a72-88b84a86c30c.png)

  - 트랜잭션이 커밋이 되면 쓰기 지연 SQL 저장소에 저장되어 있던 쿼리문들이 flush 되면서 db에 날아간다.

- 변경 감지(Dirty Checking)

  ```java
  EntityManager em = emf.createEntityManager();
  EntityTransaction transaction = em.getTransaction();
  
  transaction.begin();
  
  // 영속 엔티티 조회
  Member memberA = em.find(Member.class, "memberA");
  
  // 영속 엔티티 데이터 수정
  memberA.setUsername("newMember");
  memberA.setAge(10);
  
  tx.commit();
  ```

  ![image](https://user-images.githubusercontent.com/40904001/191946184-5321553f-f1e6-455b-bce8-f22c485fbd47.png)

- 지연 로딩(Lazy Loading)



## 플러시

- 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영

- 영속성 컨텍스트를 비우지 않는다.

### 플러시 발생

- 변경 감지
- 수정된 엔티티 쓰기 지연 SQL 저장소에 등록
- 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송

### 영속성 컨텍스트를 플러시하는 방법

- em.flush() - 직접 호출
- 트랜잭션 커밋 - 플러시 자동 호출
- JPQL 쿼리 실행 - 플러시 자동 호출

### 플러시 모드 옵션

```java
em.setFlushMode(FlushModeType.COMMIT)
```

- FlushModeType.AUTO

  커밋이나 쿼리를 실행할 때 플러시 (기본값)

- FlushModeType.COMMIT

  커밋할 때만 플러시

  

## 준영속 상태

영속 상태의 엔티티가 영속성 컨텍스트에서 분리

### 준영속 상태로 만드는 방법

- em.detach(entity)
- em.clear()
- em.close()

