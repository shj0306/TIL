# 컬렉션 페치 조인 최적화

컬렉션이 있을 때 페치 조인을 하게 되면 데이터가 뻥튀기 된다.

![image](https://user-images.githubusercontent.com/40904001/190541447-05af1000-6f72-4524-92d7-bf59600c5d33.png)

**[결과]**

똑같은 데이터가 중복되어 나타난다.

**[해결]**

JPQL에 distinct 명령어를 사용하면 JPQ에서 자체적으로 동일한 id에 대해서 중복을 제거해준다.

![image](https://user-images.githubusercontent.com/40904001/190541625-03001064-1249-4331-a21e-f9fecaa44fa1.png)



## 컬렉션 페치 조인시 주의점

- 페이징이 불가능하고, 하게 되면 하이버네이트가 경고 로그를 남기면서 모든 데이터를 DB에서 읽어와 메모리에 페이징 한다.
- 컬렉션 둘 이상일 땐 페치 조인을 사용하면 안된다.



## 컬렉션 조회 최적화

- ToOne 관계는 row수를 증가시키지 않기 때문에 모두 페치 조인한다.
- 컬렉션은 지연 로딩으로 조회한다.
- 지연 로딩 성능을 최적화하기 위해 hibernate.default_batch_fetch_size, @BatchSize를 사용한다.
  - hibernate.default_batch_fetch_size : 글로벌 설정
  - @BatchSize: 개별 최적화
  - 이 옵션을 사용하면 컬렉션이나 프록시 객체를 설정한 size만큼 in 쿼리로 조회한다.

**[결과]**

- 쿼리 호출 수가 1 + N 에서 1 + 1로 최적화된다.
- 페치 조인보다는 쿼리 호출 수가 많지만 DB 데이터 전송량이 감소한다.
- 컬렉션 페치 조인과는 다르게 페이징이 가능하다.



### JPQ에서 DTO 직접 조회 (in 쿼리 사용)

- Query: 루트 1번, 컬렉션 1번
- ToOne 관계들을 먼저 조회하고, 여기서 얻은 식별자 orderId로 ToMany 관계인 OrderItem을 한번에 조회
- map을 사용해서 매칭 성능을 향상시킴.



### 플랫 데이터 최적화

- 1개의 쿼리로 조회가 가능하다.
- 단점
  - 쿼리는 한번이지만 조인으로 인해 DB에서 애플리케이션에 전달하는 데이터에 중복 데이터가 추가되기 때문에 상황에 따라 성능 차이가 생길 수 있다.
  - 애플리케이션에서 추가 작업이 크다
  - 페이징 불가능